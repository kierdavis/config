// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go runtime

package runtime

// Frame is the information returned by Frames for each call frame.
#Frame: {
	// PC is the program counter for the location in this frame.
	// For a frame that calls another frame, this will be the
	// program counter of a call instruction. Because of inlining,
	// multiple frames may have the same PC value, but different
	// symbolic information.
	PC: uint64 @go(,uintptr)

	// Function is the package path-qualified function name of
	// this call frame. If non-empty, this string uniquely
	// identifies a single function in the program.
	// This may be the empty string if not known.
	// If Func is not nil then Function == Func.Name().
	Function: string

	// File and Line are the file name and line number of the
	// location in this frame. For non-leaf frames, this will be
	// the location of a call. These may be the empty string and
	// zero, respectively, if not known.
	File: string
	Line: int

	// Entry point program counter for the function; may be zero
	// if not known. If Func is not nil then Entry ==
	// Func.Entry().
	Entry: uint64 @go(,uintptr)
}

_#_PCDATA_UnsafePoint:          0
_#_PCDATA_StackMapIndex:        1
_#_PCDATA_InlTreeIndex:         2
_#_PCDATA_ArgLiveIndex:         3
_#_FUNCDATA_ArgsPointerMaps:    0
_#_FUNCDATA_LocalsPointerMaps:  1
_#_FUNCDATA_StackObjects:       2
_#_FUNCDATA_InlTree:            3
_#_FUNCDATA_OpenCodedDeferInfo: 4
_#_FUNCDATA_ArgInfo:            5
_#_FUNCDATA_ArgLiveInfo:        6
_#_FUNCDATA_WrapInfo:           7
_#_ArgsSizeUnknown:             -2147483648

// PCDATA_UnsafePoint values.
_#_PCDATA_UnsafePointSafe:   -1
_#_PCDATA_UnsafePointUnsafe: -2

// _PCDATA_Restart1(2) apply on a sequence of instructions, within
// which if an async preemption happens, we should back off the PC
// to the start of the sequence when resume.
// We need two so we can distinguish the start/end of the sequence
// in case that two sequences are next to each other.
_#_PCDATA_Restart1: -3
_#_PCDATA_Restart2: -4

// Like _PCDATA_RestartAtEntry, but back to function entry if async
// preempted.
_#_PCDATA_RestartAtEntry: -5

// A FuncID identifies particular functions that need to be treated
// specially by the runtime.
// Note that in some situations involving plugins, there may be multiple
// copies of a particular special runtime function.
// Note: this list must match the list in cmd/internal/objabi/funcid.go.
_#funcID: uint8

_#funcID_normal:             _#funcID & 0
_#funcID_abort:              _#funcID & 1
_#funcID_asmcgocall:         _#funcID & 2
_#funcID_asyncPreempt:       _#funcID & 3
_#funcID_cgocallback:        _#funcID & 4
_#funcID_debugCallV2:        _#funcID & 5
_#funcID_gcBgMarkWorker:     _#funcID & 6
_#funcID_goexit:             _#funcID & 7
_#funcID_gogo:               _#funcID & 8
_#funcID_gopanic:            _#funcID & 9
_#funcID_handleAsyncEvent:   _#funcID & 10
_#funcID_mcall:              _#funcID & 11
_#funcID_morestack:          _#funcID & 12
_#funcID_mstart:             _#funcID & 13
_#funcID_panicwrap:          _#funcID & 14
_#funcID_rt0_go:             _#funcID & 15
_#funcID_runfinq:            _#funcID & 16
_#funcID_runtime_main:       _#funcID & 17
_#funcID_sigpanic:           _#funcID & 18
_#funcID_systemstack:        _#funcID & 19
_#funcID_systemstack_switch: _#funcID & 20
_#funcID_wrapper:            _#funcID & 21

// A FuncFlag holds bits about a function.
// This list must match the list in cmd/internal/objabi/funcid.go.
_#funcFlag: uint8

// TOPFRAME indicates a function that appears at the top of its stack.
// The traceback routine stop at such a function and consider that a
// successful, complete traversal of the stack.
// Examples of TOPFRAME functions include goexit, which appears
// at the top of a user goroutine stack, and mstart, which appears
// at the top of a system goroutine stack.
_#funcFlag_TOPFRAME: _#funcFlag & 1

// SPWRITE indicates a function that writes an arbitrary value to SP
// (any write other than adding or subtracting a constant amount).
// The traceback routines cannot encode such changes into the
// pcsp tables, so the function traceback cannot safely unwind past
// SPWRITE functions. Stopping at an SPWRITE function is considered
// to be an incomplete unwinding of the stack. In certain contexts
// (in particular garbage collector stack scans) that is a fatal error.
_#funcFlag_SPWRITE: _#funcFlag & 2

// ASM indicates that a function was implemented in assembly.
_#funcFlag_ASM: _#funcFlag & 4

_#minfunc: 16

_#pcbucketsize: 4096

_#debugPcln: false
