// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go runtime

package runtime

// minPhysPageSize is a lower-bound on the physical page size. The
// true physical page size may be larger than this. In contrast,
// sys.PhysPageSize is an upper-bound on the physical page size.
_#minPhysPageSize: 4096

// maxPhysPageSize is the maximum page size the runtime supports.
_#maxPhysPageSize: 524288

// maxPhysHugePageSize sets an upper-bound on the maximum huge page size
// that the runtime supports.
_#maxPhysHugePageSize: 4194304

// pagesPerReclaimerChunk indicates how many pages to scan from the
// pageInUse bitmap at a time. Used by the page reclaimer.
//
// Higher values reduce contention on scanning indexes (such as
// h.reclaimIndex), but increase the minimum latency of the
// operation.
//
// The time required to scan this many pages can vary a lot depending
// on how many spans are actually freed. Experimentally, it can
// scan for pages at ~300 GB/ms on a 2.6GHz Core i7, but can only
// free spans at ~32 MB/ms. Using 512 pages bounds this at
// roughly 100Âµs.
//
// Must be a multiple of the pageInUse bitmap element size and
// must also evenly divide pagesPerArena.
_#pagesPerReclaimerChunk: 512

// physPageAlignedStacks indicates whether stack allocations must be
// physical page aligned. This is a requirement for MAP_STACK on
// OpenBSD.
_#physPageAlignedStacks: false

// An mspan representing actual memory has state mSpanInUse,
// mSpanManual, or mSpanFree. Transitions between these states are
// constrained as follows:
//
//   - A span may transition from free to in-use or manual during any GC
//     phase.
//
//   - During sweeping (gcphase == _GCoff), a span may transition from
//     in-use to free (as a result of sweeping) or manual to free (as a
//     result of stacks being freed).
//
//   - During GC (gcphase != _GCoff), a span *must not* transition from
//     manual or in-use to free. Because concurrent GC may read a pointer
//     and then look up its span, the span state must be monotonic.
//
// Setting mspan.state to mSpanInUse or mSpanManual must be done
// atomically and only after all other span fields are valid.
// Likewise, if inspecting a span is contingent on it being
// mSpanInUse, the state should be loaded atomically and checked
// before depending on other fields. This allows the garbage collector
// to safely deal with potentially invalid pointers, since resolving
// such pointers may race with a span being allocated.
_#mSpanState: uint8

_#mSpanDead:   _#mSpanState & 0
_#mSpanInUse:  _#mSpanState & 1
_#mSpanManual: _#mSpanState & 2

// A spanClass represents the size class and noscan-ness of a span.
//
// Each size class has a noscan spanClass and a scan spanClass. The
// noscan spanClass contains only noscan objects, which do not contain
// pointers and thus do not need to be scanned by the garbage
// collector.
_#spanClass: uint8

_#numSpanClasses: 136
_#tinySpanClass:  _#spanClass & 5

_#arenaIdx: uint

// spanAllocType represents the type of allocation to make, or
// the type of allocation to be freed.
_#spanAllocType: uint8

_#spanAllocHeap:          _#spanAllocType & 0
_#spanAllocStack:         _#spanAllocType & 1
_#spanAllocPtrScalarBits: _#spanAllocType & 2
_#spanAllocWorkBuf:       _#spanAllocType & 3

_#_KindSpecialFinalizer: 1
_#_KindSpecialProfile:   2

// _KindSpecialReachable is a special used for tracking
// reachability during testing.
_#_KindSpecialReachable: 3

// gcBits is an alloc/mark bitmap. This is always used as *gcBits.
//
//go:notinheap
_#gcBits: uint8

_#gcBitsChunkBytes: uint64 & 65536

_#gcBitsHeaderBytes: uint64 & 16
