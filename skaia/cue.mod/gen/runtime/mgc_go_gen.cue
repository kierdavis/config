// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go runtime

package runtime

_#_DebugGC:         0
_#_ConcurrentSweep: true
_#_FinBlockSize:    4096

// debugScanConservative enables debug logging for stack
// frames that are scanned conservatively.
_#debugScanConservative: false

// sweepMinHeapDistance is a lower bound on the heap distance
// (in bytes) reserved for concurrent sweeping between GC
// cycles.
_#sweepMinHeapDistance: 1048576

_#_GCoff:             0
_#_GCmark:            1
_#_GCmarktermination: 2

// gcMarkWorkerMode represents the mode that a concurrent mark worker
// should operate in.
//
// Concurrent marking happens through four different mechanisms. One
// is mutator assists, which happen in response to allocations and are
// not scheduled. The other three are variations in the per-P mark
// workers and are distinguished by gcMarkWorkerMode.
_#gcMarkWorkerMode: int

// gcMarkWorkerNotWorker indicates that the next scheduled G is not
// starting work and the mode should be ignored.
_#gcMarkWorkerNotWorker: _#gcMarkWorkerMode & 0

// gcMarkWorkerDedicatedMode indicates that the P of a mark
// worker is dedicated to running that mark worker. The mark
// worker should run without preemption.
_#gcMarkWorkerDedicatedMode: _#gcMarkWorkerMode & 1

// gcMarkWorkerFractionalMode indicates that a P is currently
// running the "fractional" mark worker. The fractional worker
// is necessary when GOMAXPROCS*gcBackgroundUtilization is not
// an integer and using only dedicated workers would result in
// utilization too far from the target of gcBackgroundUtilization.
// The fractional worker should run until it is preempted and
// will be scheduled to pick up the fractional part of
// GOMAXPROCS*gcBackgroundUtilization.
_#gcMarkWorkerFractionalMode: _#gcMarkWorkerMode & 2

// gcMarkWorkerIdleMode indicates that a P is running the mark
// worker because it has nothing else to do. The idle worker
// should run until it is preempted and account its time
// against gcController.idleMarkTime.
_#gcMarkWorkerIdleMode: _#gcMarkWorkerMode & 3

// gcMode indicates how concurrent a GC cycle should be.
_#gcMode: int

_#gcBackgroundMode: _#gcMode & 0
_#gcForceMode:      _#gcMode & 1
_#gcForceBlockMode: _#gcMode & 2

_#gcTriggerKind: int

// gcTriggerHeap indicates that a cycle should be started when
// the heap size reaches the trigger heap size computed by the
// controller.
_#gcTriggerHeap: _#gcTriggerKind & 0

// gcTriggerTime indicates that a cycle should be started when
// it's been more than forcegcperiod nanoseconds since the
// previous GC cycle.
_#gcTriggerTime: _#gcTriggerKind & 1

// gcTriggerCycle indicates that a cycle should be started if
// we have not yet started cycle number gcTrigger.n (relative
// to work.cycles).
_#gcTriggerCycle: _#gcTriggerKind & 2
