// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go runtime

package runtime

// _Gidle means this goroutine was just allocated and has not
// yet been initialized.
_#_Gidle: 0

// _Grunnable means this goroutine is on a run queue. It is
// not currently executing user code. The stack is not owned.
_#_Grunnable: 1

// _Grunning means this goroutine may execute user code. The
// stack is owned by this goroutine. It is not on a run queue.
// It is assigned an M and a P (g.m and g.m.p are valid).
_#_Grunning: 2

// _Gsyscall means this goroutine is executing a system call.
// It is not executing user code. The stack is owned by this
// goroutine. It is not on a run queue. It is assigned an M.
_#_Gsyscall: 3

// _Gwaiting means this goroutine is blocked in the runtime.
// It is not executing user code. It is not on a run queue,
// but should be recorded somewhere (e.g., a channel wait
// queue) so it can be ready()d when necessary. The stack is
// not owned *except* that a channel operation may read or
// write parts of the stack under the appropriate channel
// lock. Otherwise, it is not safe to access the stack after a
// goroutine enters _Gwaiting (e.g., it may get moved).
_#_Gwaiting: 4

// _Gmoribund_unused is currently unused, but hardcoded in gdb
// scripts.
_#_Gmoribund_unused: 5

// _Gdead means this goroutine is currently unused. It may be
// just exited, on a free list, or just being initialized. It
// is not executing user code. It may or may not have a stack
// allocated. The G and its stack (if any) are owned by the M
// that is exiting the G or that obtained the G from the free
// list.
_#_Gdead: 6

// _Genqueue_unused is currently unused.
_#_Genqueue_unused: 7

// _Gcopystack means this goroutine's stack is being moved. It
// is not executing user code and is not on a run queue. The
// stack is owned by the goroutine that put it in _Gcopystack.
_#_Gcopystack: 8

// _Gpreempted means this goroutine stopped itself for a
// suspendG preemption. It is like _Gwaiting, but nothing is
// yet responsible for ready()ing it. Some suspendG must CAS
// the status to _Gwaiting to take responsibility for
// ready()ing this G.
_#_Gpreempted: 9

// _Gscan combined with one of the above states other than
// _Grunning indicates that GC is scanning the stack. The
// goroutine is not executing user code and the stack is owned
// by the goroutine that set the _Gscan bit.
//
// _Gscanrunning is different: it is used to briefly block
// state transitions while GC signals the G to scan its own
// stack. This is otherwise like _Grunning.
//
// atomicstatus&~Gscan gives the state the goroutine will
// return to when the scan completes.
_#_Gscan:          0x1000
_#_Gscanrunnable:  4097
_#_Gscanrunning:   4098
_#_Gscansyscall:   4099
_#_Gscanwaiting:   4100
_#_Gscanpreempted: 4105

// _Pidle means a P is not being used to run user code or the
// scheduler. Typically, it's on the idle P list and available
// to the scheduler, but it may just be transitioning between
// other states.
//
// The P is owned by the idle list or by whatever is
// transitioning its state. Its run queue is empty.
_#_Pidle: 0

// _Prunning means a P is owned by an M and is being used to
// run user code or the scheduler. Only the M that owns this P
// is allowed to change the P's status from _Prunning. The M
// may transition the P to _Pidle (if it has no more work to
// do), _Psyscall (when entering a syscall), or _Pgcstop (to
// halt for the GC). The M may also hand ownership of the P
// off directly to another M (e.g., to schedule a locked G).
_#_Prunning: 1

// _Psyscall means a P is not running user code. It has
// affinity to an M in a syscall but is not owned by it and
// may be stolen by another M. This is similar to _Pidle but
// uses lightweight transitions and maintains M affinity.
//
// Leaving _Psyscall must be done with a CAS, either to steal
// or retake the P. Note that there's an ABA hazard: even if
// an M successfully CASes its original P back to _Prunning
// after a syscall, it must understand the P may have been
// used by another M in the interim.
_#_Psyscall: 2

// _Pgcstop means a P is halted for STW and owned by the M
// that stopped the world. The M that stopped the world
// continues to use its P, even in _Pgcstop. Transitioning
// from _Prunning to _Pgcstop causes an M to release its P and
// park.
//
// The P retains its run queue and startTheWorld will restart
// the scheduler on Ps with non-empty run queues.
_#_Pgcstop: 3

// _Pdead means a P is no longer used (GOMAXPROCS shrank). We
// reuse Ps if GOMAXPROCS increases. A dead P is mostly
// stripped of its resources, though a few things remain
// (e.g., trace buffers).
_#_Pdead: 4

// A guintptr holds a goroutine pointer, but typed as a uintptr
// to bypass write barriers. It is used in the Gobuf goroutine state
// and in scheduling lists that are manipulated without a P.
//
// The Gobuf.g goroutine pointer is almost always updated by assembly code.
// In one of the few places it is updated by Go code - func save - it must be
// treated as a uintptr to avoid a write barrier being emitted at a bad time.
// Instead of figuring out how to emit the write barriers missing in the
// assembly manipulation, we change the type of the field to uintptr,
// so that it does not require write barriers at all.
//
// Goroutine structs are published in the allg list and never freed.
// That will keep the goroutine structs from being collected.
// There is never a time that Gobuf.g's contain the only references
// to a goroutine: the publishing of the goroutine in allg comes first.
// Goroutine pointers are also kept in non-GC-visible places like TLS,
// so I can't see them ever moving. If we did want to start moving data
// in the GC, we'd need to allocate the goroutine structs from an
// alternate arena. Using guintptr doesn't make that problem any worse.
// Note that pollDesc.rg, pollDesc.wg also store g in uintptr form,
// so they would need to be updated too if g's start moving.
_#guintptr: uint64

_#puintptr: uint64

// muintptr is a *m that is not tracked by the garbage collector.
//
// Because we do free Ms, there are some additional constrains on
// muintptrs:
//
//  1. Never hold an muintptr locally across a safe point.
//
//  2. Any muintptr in the heap must be owned by the M itself so it can
//     ensure it is not in use when the last true *m is released.
_#muintptr: uint64

_#gTrackingPeriod: 8

// tlsSlots is the number of pointer-sized slots reserved for TLS on some platforms,
// like Windows.
_#tlsSlots: 6
_#tlsSize:  48

_#freeMStack: 0
_#freeMRef:   1
_#freeMWait:  2

_#_SigNotify:   1
_#_SigKill:     2
_#_SigThrow:    4
_#_SigPanic:    8
_#_SigDefault:  16
_#_SigGoExit:   32
_#_SigSetStack: 64
_#_SigUnblock:  128
_#_SigIgn:      256

_#_TraceRuntimeFrames: 1
_#_TraceTrap:          2
_#_TraceJumpStack:     4

_#_TracebackMaxFrames: 100

// A waitReason explains why a goroutine has been stopped.
// See gopark. Do not re-use waitReasons, add new ones.
_#waitReason: uint8

_#waitReasonZero:                  _#waitReason & 0
_#waitReasonGCAssistMarking:       _#waitReason & 1
_#waitReasonIOWait:                _#waitReason & 2
_#waitReasonChanReceiveNilChan:    _#waitReason & 3
_#waitReasonChanSendNilChan:       _#waitReason & 4
_#waitReasonDumpingHeap:           _#waitReason & 5
_#waitReasonGarbageCollection:     _#waitReason & 6
_#waitReasonGarbageCollectionScan: _#waitReason & 7
_#waitReasonPanicWait:             _#waitReason & 8
_#waitReasonSelect:                _#waitReason & 9
_#waitReasonSelectNoCases:         _#waitReason & 10
_#waitReasonGCAssistWait:          _#waitReason & 11
_#waitReasonGCSweepWait:           _#waitReason & 12
_#waitReasonGCScavengeWait:        _#waitReason & 13
_#waitReasonChanReceive:           _#waitReason & 14
_#waitReasonChanSend:              _#waitReason & 15
_#waitReasonFinalizerWait:         _#waitReason & 16
_#waitReasonForceGCIdle:           _#waitReason & 17
_#waitReasonSemacquire:            _#waitReason & 18
_#waitReasonSleep:                 _#waitReason & 19
_#waitReasonSyncCondWait:          _#waitReason & 20
_#waitReasonTimerGoroutineIdle:    _#waitReason & 21
_#waitReasonTraceReaderBlocked:    _#waitReason & 22
_#waitReasonWaitForGCCycle:        _#waitReason & 23
_#waitReasonGCWorkerIdle:          _#waitReason & 24
_#waitReasonPreempted:             _#waitReason & 25
_#waitReasonDebugCall:             _#waitReason & 26

_#framepointer_enabled: true
