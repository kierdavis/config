// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go kmodules.xyz/offshoot-api/api/v1

package v1

import core "k8s.io/api/core/v1"

// ObjectMeta is metadata that all persisted resources must have, which includes all objects
// users must create.
#ObjectMeta: {
	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects. May match selectors of replication controllers
	// and services.
	// More info: http://kubernetes.io/docs/user-guide/labels
	// +optional
	labels?: {[string]: string} @go(Labels,map[string]string) @protobuf(1,bytes,rep)

	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata. They are not
	// queryable and should be preserved when modifying objects.
	// More info: http://kubernetes.io/docs/user-guide/annotations
	// +optional
	annotations?: {[string]: string} @go(Annotations,map[string]string) @protobuf(2,bytes,rep)
}

// PodTemplateSpec describes the data a pod should have when created from a template
#PodTemplateSpec: {
	// Standard object's metadata.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
	// +optional
	metadata?: #ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)

	// Workload controller's metadata.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
	// +optional
	controller?: #ObjectMeta @go(Controller) @protobuf(2,bytes,opt)

	// Specification of the desired behavior of the pod.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
	// +optional
	spec?: #PodSpec @go(Spec) @protobuf(3,bytes,opt)
}

#PodSpec: {
	// ServiceAccountName is the name of the ServiceAccount to use to run this pod.
	// More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
	// +optional
	serviceAccountName?: string @go(ServiceAccountName) @protobuf(1,bytes,opt)

	// NodeSelector is a selector which must be true for the pod to fit on a node.
	// Selector which must match a node's labels for the pod to be scheduled on that node.
	// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
	// +optional
	nodeSelector?: {[string]: string} @go(NodeSelector,map[string]string) @protobuf(2,bytes,rep)

	// If specified, the pod's scheduling constraints
	// +optional
	affinity?: null | core.#Affinity @go(Affinity,*core.Affinity) @protobuf(3,bytes,opt)

	// If specified, the pod will be dispatched by specified scheduler.
	// If not specified, the pod will be dispatched by default scheduler.
	// +optional
	schedulerName?: string @go(SchedulerName) @protobuf(4,bytes,opt)

	// If specified, the pod's tolerations.
	// +optional
	tolerations?: [...core.#Toleration] @go(Tolerations,[]core.Toleration) @protobuf(5,bytes,rep)

	// ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
	// If specified, these secrets will be passed to individual puller implementations for them to use.
	// +optional
	imagePullSecrets?: [...core.#LocalObjectReference] @go(ImagePullSecrets,[]core.LocalObjectReference) @protobuf(6,bytes,rep)

	// If specified, indicates the pod's priority. "system-node-critical" and
	// "system-cluster-critical" are two special keywords which indicate the
	// highest priorities with the former being the highest priority. Any other
	// name must be defined by creating a PriorityClass object with that name.
	// If not specified, the pod priority will be default or zero if there is no
	// default.
	// +optional
	priorityClassName?: string @go(PriorityClassName) @protobuf(7,bytes,opt)

	// The priority value. Various system components use this field to find the
	// priority of the pod. When Priority Admission Controller is enabled, it
	// prevents users from setting this field. The admission controller populates
	// this field from PriorityClassName.
	// The higher the value, the higher the priority.
	// +optional
	priority?: null | int32 @go(Priority,*int32) @protobuf(8,varint,opt)

	// Host networking requested for this pod. Use the host's network namespace.
	// If this option is set, the ports that will be used must be specified.
	// Default to false.
	// +k8s:conversion-gen=false
	// +optional
	hostNetwork?: bool @go(HostNetwork) @protobuf(9,varint,opt)

	// Use the host's pid namespace.
	// Optional: Default to false.
	// +k8s:conversion-gen=false
	// +optional
	hostPID?: bool @go(HostPID) @protobuf(10,varint,opt)

	// Use the host's ipc namespace.
	// Optional: Default to false.
	// +k8s:conversion-gen=false
	// +optional
	hostIPC?: bool @go(HostIPC) @protobuf(11,varint,opt)

	// Share a single process namespace between all of the containers in a pod.
	// When this is set containers will be able to view and signal processes from other containers
	// in the same pod, and the first process in each container will not be assigned PID 1.
	// HostPID and ShareProcessNamespace cannot both be set.
	// Optional: Default to false.
	// +k8s:conversion-gen=false
	// +optional
	shareProcessNamespace?: null | bool @go(ShareProcessNamespace,*bool) @protobuf(12,varint,opt)

	// SecurityContext holds pod-level security attributes and common container settings.
	// Optional: Defaults to empty.  See type description for default values of each field.
	// +optional
	securityContext?: null | core.#PodSecurityContext @go(SecurityContext,*core.PodSecurityContext) @protobuf(13,bytes,opt)

	// Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
	// Value must be non-negative integer. The value zero indicates stop immediately via
	// the kill signal (no opportunity to shut down).
	// If this value is nil, the default grace period will be used instead.
	// The grace period is the duration in seconds after the processes running in the pod are sent
	// a termination signal and the time when the processes are forcibly halted with a kill signal.
	// Set this value longer than the expected cleanup time for your process.
	// Defaults to 30 seconds.
	// +optional
	terminationGracePeriodSeconds?: null | int64 @go(TerminationGracePeriodSeconds,*int64) @protobuf(14,varint,opt)

	// Set DNS policy for the pod.
	// Defaults to "ClusterFirst".
	// Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
	// DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
	// To have DNS options set along with hostNetwork, you have to specify DNS policy
	// explicitly to 'ClusterFirstWithHostNet'.
	// +optional
	dnsPolicy?: core.#DNSPolicy @go(DNSPolicy) @protobuf(15,bytes,opt,casttype=k8s.io/api/core/v1.DNSPolicy)

	// Specifies the DNS parameters of a pod.
	// Parameters specified here will be merged to the generated DNS
	// configuration based on DNSPolicy.
	// +optional
	dnsConfig?: null | core.#PodDNSConfig @go(DNSConfig,*core.PodDNSConfig) @protobuf(16,bytes,opt)

	// TopologySpreadConstraints describes how a group of pods ought to spread across topology
	// domains. Scheduler will schedule pods in a way which abides by the constraints.
	// All topologySpreadConstraints are ANDed.
	// +optional
	// +patchMergeKey=topologyKey
	// +patchStrategy=merge
	// +listType=map
	// +listMapKey=topologyKey
	// +listMapKey=whenUnsatisfiable
	topologySpreadConstraints?: [...core.#TopologySpreadConstraint] @go(TopologySpreadConstraints,[]core.TopologySpreadConstraint) @protobuf(17,bytes,rep)

	// List of volumes that can be mounted by containers belonging to the pod.
	// More info: https://kubernetes.io/docs/concepts/storage/volumes
	// +optional
	// +patchMergeKey=name
	// +patchStrategy=merge,retainKeys
	volumes?: [...core.#Volume] @go(Volumes,[]core.Volume) @protobuf(18,bytes,rep)

	// List of initialization containers belonging to the pod.
	// Init containers are executed in order prior to containers being started. If any
	// init container fails, the pod is considered to have failed and is handled according
	// to its restartPolicy. The name for an init container or normal container must be
	// unique among all containers.
	// Init containers may not have Lifecycle actions, Readiness probes, or Liveness probes.
	// The resourceRequirements of an init container are taken into account during scheduling
	// by finding the highest request/limit for each resource type, and then using the max of
	// of that value or the sum of the normal containers. Limits are applied to init containers
	// in a similar fashion.
	// Init containers cannot currently be added or removed.
	// Cannot be updated.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
	// +patchMergeKey=name
	// +patchStrategy=merge
	initContainers?: [...core.#Container] @go(InitContainers,[]core.Container) @protobuf(19,bytes,rep)

	// Arguments to the entrypoint.
	// The docker image's CMD is used if this is not provided.
	// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
	// cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
	// can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
	// regardless of whether the variable exists or not.
	// Cannot be updated.
	// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
	// +optional
	args?: [...string] @go(Args,[]string) @protobuf(20,bytes,rep)

	// List of environment variables to set in the container.
	// Cannot be updated.
	// +optional
	env?: [...core.#EnvVar] @go(Env,[]core.EnvVar) @protobuf(21,bytes,rep)

	// Compute Resources required by the sidecar container.
	// +optional
	resources?: core.#ResourceRequirements @go(Resources) @protobuf(22,bytes,opt)

	// Periodic probe of container liveness.
	// Container will be restarted if the probe fails.
	// Controllers may set default LivenessProbe if no liveness probe is provided.
	// To ignore defaulting, set the value to empty LivenessProbe "{}".
	// Cannot be updated.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
	// +optional
	livenessProbe?: null | core.#Probe @go(LivenessProbe,*core.Probe) @protobuf(23,bytes,opt)

	// Periodic probe of container service readiness.
	// Container will be removed from service endpoints if the probe fails.
	// Cannot be updated.
	// Controllers may set default ReadinessProbe if no readyness probe is provided.
	// To ignore defaulting, set the value to empty ReadynessProbe "{}".
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
	// +optional
	readinessProbe?: null | core.#Probe @go(ReadinessProbe,*core.Probe) @protobuf(24,bytes,opt)

	// Actions that the management system should take in response to container lifecycle events.
	// Cannot be updated.
	// +optional
	lifecycle?: null | core.#Lifecycle @go(Lifecycle,*core.Lifecycle) @protobuf(25,bytes,opt)

	// Security options the pod should run with.
	// More info: https://kubernetes.io/docs/concepts/policy/security-context/
	// More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
	// +optional
	containerSecurityContext?: null | core.#SecurityContext @go(ContainerSecurityContext,*core.SecurityContext) @protobuf(26,bytes,opt)

	// Pod volumes to mount into the container's filesystem.
	// Cannot be updated.
	// +optional
	// +patchMergeKey=mountPath
	// +patchStrategy=merge
	volumeMounts?: [...core.#VolumeMount] @go(VolumeMounts,[]core.VolumeMount) @protobuf(27,bytes,rep)
}

// ServiceTemplateSpec describes the data a service should have when created from a template
#ServiceTemplateSpec: {
	// Standard object's metadata.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
	// +optional
	metadata?: #ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)

	// Specification of the desired behavior of the service.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
	// +optional
	spec?: #ServiceSpec @go(Spec) @protobuf(2,bytes,opt)
}

// ServiceSpec describes the attributes that a user creates on a service.
#ServiceSpec: {
	// The list of ports that are exposed by this service.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	// +patchMergeKey=port
	// +patchStrategy=merge
	ports?: [...#ServicePort] @go(Ports,[]ServicePort) @protobuf(1,bytes,rep)

	// clusterIP is the IP address of the service and is usually assigned
	// randomly by the master. If an address is specified manually and is not in
	// use by others, it will be allocated to the service; otherwise, creation
	// of the service will fail. This field can not be changed through updates.
	// Valid values are "None", empty string (""), or a valid IP address. "None"
	// can be specified for headless services when proxying is not required.
	// Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if
	// type is ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	// +optional
	clusterIP?: string @go(ClusterIP) @protobuf(2,bytes,opt)

	// type determines how the Service is exposed. Defaults to ClusterIP. Valid
	// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
	// "ExternalName" maps to the specified externalName.
	// "ClusterIP" allocates a cluster-internal IP address for load-balancing to
	// endpoints. Endpoints are determined by the selector or if that is not
	// specified, by manual construction of an Endpoints object. If clusterIP is
	// "None", no virtual IP is allocated and the endpoints are published as a
	// set of endpoints rather than a stable IP.
	// "NodePort" builds on ClusterIP and allocates a port on every node which
	// routes to the clusterIP.
	// "LoadBalancer" builds on NodePort and creates an
	// external load-balancer (if supported in the current cloud) which routes
	// to the clusterIP.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types
	// +optional
	type?: core.#ServiceType @go(Type) @protobuf(3,bytes,opt,casttype=k8s.io/api/core/v1.ServiceType)

	// externalIPs is a list of IP addresses for which nodes in the cluster
	// will also accept traffic for this service.  These IPs are not managed by
	// Kubernetes.  The user is responsible for ensuring that traffic arrives
	// at a node with this IP.  A common example is external load-balancers
	// that are not part of the Kubernetes system.
	// +optional
	externalIPs?: [...string] @go(ExternalIPs,[]string) @protobuf(4,bytes,rep)

	// Only applies to Service Type: LoadBalancer
	// LoadBalancer will get created with the IP specified in this field.
	// This feature depends on whether the underlying cloud-provider supports specifying
	// the loadBalancerIP when a load balancer is created.
	// This field will be ignored if the cloud-provider does not support the feature.
	// +optional
	loadBalancerIP?: string @go(LoadBalancerIP) @protobuf(5,bytes,opt)

	// If specified and supported by the platform, this will restrict traffic through the cloud-provider
	// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
	// cloud-provider does not support the feature."
	// More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/
	// +optional
	loadBalancerSourceRanges?: [...string] @go(LoadBalancerSourceRanges,[]string) @protobuf(6,bytes,rep)

	// externalTrafficPolicy denotes if this Service desires to route external
	// traffic to node-local or cluster-wide endpoints. "Local" preserves the
	// client source IP and avoids a second hop for LoadBalancer and Nodeport
	// type services, but risks potentially imbalanced traffic spreading.
	// "Cluster" obscures the client source IP and may cause a second hop to
	// another node, but should have good overall load-spreading.
	// +optional
	externalTrafficPolicy?: core.#ServiceExternalTrafficPolicyType @go(ExternalTrafficPolicy) @protobuf(7,bytes,opt,casttype=k8s.io/api/core/v1.ServiceExternalTrafficPolicyType)

	// healthCheckNodePort specifies the healthcheck nodePort for the service.
	// If not specified, HealthCheckNodePort is created by the service api
	// backend with the allocated nodePort. Will use user-specified nodePort value
	// if specified by the client. Only effects when Type is set to LoadBalancer
	// and ExternalTrafficPolicy is set to Local.
	// +optional
	healthCheckNodePort?: int32 @go(HealthCheckNodePort) @protobuf(8,varint,opt)

	// sessionAffinityConfig contains the configurations of session affinity.
	// +optional
	sessionAffinityConfig?: null | core.#SessionAffinityConfig @go(SessionAffinityConfig,*core.SessionAffinityConfig) @protobuf(9,bytes,opt)
}

// ServicePort contains information on service's port.
#ServicePort: {
	// The name of this port within the service. This must be a DNS_LABEL.
	// All ports within a ServiceSpec must have unique names. This maps to
	// the 'Name' field in EndpointPort objects.
	// Optional if only one ServicePort is defined on this service.
	// +optional
	name?: string @go(Name) @protobuf(1,bytes,opt)

	// The port that will be exposed by this service.
	port: int32 @go(Port) @protobuf(2,varint,opt)

	// The port on each node on which this service is exposed when type=NodePort or LoadBalancer.
	// Usually assigned by the system. If specified, it will be allocated to the service
	// if unused or else creation of the service will fail.
	// Default is to auto-allocate a port if the ServiceType of this Service requires one.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
	// +optional
	nodePort?: int32 @go(NodePort) @protobuf(3,varint,opt)
}
