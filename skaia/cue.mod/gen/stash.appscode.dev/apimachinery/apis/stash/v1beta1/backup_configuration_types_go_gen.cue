// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go stash.appscode.dev/apimachinery/apis/stash/v1beta1

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	ofst "kmodules.xyz/offshoot-api/api/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"stash.appscode.dev/apimachinery/apis/stash/v1alpha1"
	prober "kmodules.xyz/prober/api/v1"
	core "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
)

#ResourceKindBackupConfiguration:     "BackupConfiguration"
#ResourceSingularBackupConfiguration: "backupconfiguration"
#ResourcePluralBackupConfiguration:   "backupconfigurations"

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=backupconfigurations,singular=backupconfiguration,shortName=bc,categories={stash,appscode,all}
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Task",type="string",JSONPath=".spec.task.name"
// +kubebuilder:printcolumn:name="Schedule",type="string",JSONPath=".spec.schedule"
// +kubebuilder:printcolumn:name="Paused",type="boolean",JSONPath=".spec.paused"
// +kubebuilder:printcolumn:name="Phase",type="string",JSONPath=".status.phase"
// +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp"
#BackupConfiguration: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta         @go(ObjectMeta)
	spec?:     #BackupConfigurationSpec   @go(Spec)
	status?:   #BackupConfigurationStatus @go(Status)
}

#BackupConfigurationTemplateSpec: {
	// Task specify the Task crd that specifies the steps to take backup
	// +optional
	task?: #TaskRef @go(Task)

	// Target specify the backup target
	// +optional
	target?: null | #BackupTarget @go(Target,*BackupTarget)

	// RuntimeSettings allow to specify Resources, NodeSelector, Affinity, Toleration, ReadinessProbe etc.
	// +optional
	runtimeSettings?: ofst.#RuntimeSettings @go(RuntimeSettings)

	// Temp directory configuration for functions/sidecar
	// An `EmptyDir` will always be mounted at /tmp with this settings
	// +optional
	tempDir?: #EmptyDirSettings @go(TempDir)

	// InterimVolumeTemplate specifies a template for a volume to hold targeted data temporarily
	// before uploading to backend or inserting into target. It is only usable for job model.
	// Don't specify it in sidecar model.
	// +optional
	interimVolumeTemplate?: null | ofst.#PersistentVolumeClaim @go(InterimVolumeTemplate,*ofst.PersistentVolumeClaim)

	// Actions that Stash should take in response to backup sessions.
	// +optional
	hooks?: null | #BackupHooks @go(Hooks,*BackupHooks)
}

#BackupConfigurationSpec: {
	#BackupConfigurationTemplateSpec

	// Schedule specifies the schedule for invoking backup sessions
	// +optional
	schedule?: string @go(Schedule)

	// Driver indicates the name of the agent to use to backup the target.
	// Supported values are "Restic", "VolumeSnapshotter".
	// Default value is "Restic".
	// +optional
	// +kubebuilder:default=Restic
	driver?: #Snapshotter @go(Driver)

	// Repository refer to the Repository crd that holds backend information
	// +optional
	repository?: kmapi.#ObjectReference @go(Repository)

	// RetentionPolicy indicates the policy to follow to clean old backup snapshots
	retentionPolicy: v1alpha1.#RetentionPolicy @go(RetentionPolicy)

	// Indicates that the BackupConfiguration is paused from taking backup. Default value is 'false'
	// +optional
	paused?: bool @go(Paused)

	// BackupHistoryLimit specifies the number of BackupSession and it's associate resources to keep.
	// This is helpful for debugging purpose.
	// Default: 1
	// +optional
	backupHistoryLimit?: null | int32 @go(BackupHistoryLimit,*int32)

	// TimeOut specifies the maximum duration of backup. BackupSession will be considered Failed
	// if backup does not complete within this time limit. By default, Stash don't set any timeout for backup.
	// +optional
	timeOut?: null | metav1.#Duration @go(TimeOut,*metav1.Duration)

	// RetryConfig specify a configuration for retry a backup if it fails.
	// By default, Stash does not retry any failed backup.
	// +optional
	retryConfig?: null | #RetryConfig @go(RetryConfig,*RetryConfig)
}

// Hooks describes actions that Stash should take in response to backup sessions. For the PostBackup
// and PreBackup handlers, backup process blocks until the action is complete,
// unless the container process fails, in which case the handler is aborted.
#BackupHooks: {
	// PreBackup is called immediately before a backup session is initiated.
	// +optional
	preBackup?: null | prober.#Handler @go(PreBackup,*prober.Handler)

	// PostBackup is called according to executionPolicy after a backup session is complete.
	// +optional
	postBackup?: null | #PostBackupHook @go(PostBackup,*PostBackupHook)
}

#PostBackupHook: {
	prober.#Handler

	// ExecutionPolicy specifies when to execute a hook.
	// Supported values are "Always", "OnFailure", "OnSuccess".
	// Default value: "Always".
	// +optional
	// +kubebuilder:default=Always
	// +kubebuilder:validation:Enum=Always;OnFailure;OnSuccess
	executionPolicy?: #HookExecutionPolicy @go(ExecutionPolicy)
}

#HookExecutionPolicy: string // #enumHookExecutionPolicy

#enumHookExecutionPolicy:
	#ExecuteAlways |
	#ExecuteOnFailure |
	#ExecuteOnSuccess

#ExecuteAlways:    #HookExecutionPolicy & "Always"
#ExecuteOnFailure: #HookExecutionPolicy & "OnFailure"
#ExecuteOnSuccess: #HookExecutionPolicy & "OnSuccess"

#EmptyDirSettings: {
	medium?:    core.#StorageMedium       @go(Medium)
	sizeLimit?: null | resource.#Quantity @go(SizeLimit,*resource.Quantity)

	// More info: https://github.com/restic/restic/blob/master/doc/manual_rest.rst#caching
	disableCaching?: bool @go(DisableCaching)
}

// +kubebuilder:validation:Enum=Restic;VolumeSnapshotter
#Snapshotter: string // #enumSnapshotter

#enumSnapshotter:
	#ResticSnapshotter |
	#VolumeSnapshotter

#ResticSnapshotter: #Snapshotter & "Restic"
#VolumeSnapshotter: #Snapshotter & "VolumeSnapshotter"

#BackupConfigurationStatus: {
	// ObservedGeneration is the most recent generation observed for this BackupConfiguration. It corresponds to the
	// BackupConfiguration's generation, which is updated on mutation by the API Server.
	// +optional
	observedGeneration?: int64 @go(ObservedGeneration)

	// Conditions shows current backup setup condition of the BackupConfiguration.
	// +optional
	conditions?: [...kmapi.#Condition] @go(Conditions,[]kmapi.Condition)

	// Phase indicates phase of this BackupConfiguration.
	// +optional
	phase?: #BackupInvokerPhase @go(Phase)
}

#BackupConfigurationList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items?: [...#BackupConfiguration] @go(Items,[]BackupConfiguration)
}

// +kubebuilder:validation:Enum=Invalid;Ready;NotReady
#BackupInvokerPhase: string // #enumBackupInvokerPhase

#enumBackupInvokerPhase:
	#BackupInvokerInvalid |
	#BackupInvokerReady |
	#BackupInvokerNotReady

#BackupInvokerInvalid:  #BackupInvokerPhase & "Invalid"
#BackupInvokerReady:    #BackupInvokerPhase & "Ready"
#BackupInvokerNotReady: #BackupInvokerPhase & "NotReady"

// BackupTargetFound indicates whether the backup target was found
#BackupTargetFound: "BackupTargetFound"

// StashSidecarInjected indicates whether stash sidecar was injected into the targeted workload
// This condition is applicable only for sidecar model
#StashSidecarInjected: "StashSidecarInjected"

// CronJobCreated indicates whether the backup triggering CronJob was created
#CronJobCreated: "CronJobCreated"

// RepositoryFound indicates whether the respective Repository object was found or not.
#RepositoryFound: "RepositoryFound"

// BackendSecretFound indicates whether the respective backend secret was found or not.
#BackendSecretFound: "BackendSecretFound"

// ValidationPassed indicates the validation conditions of the CRD are passed or not.
#ValidationPassed: "ValidationPassed"

// TargetAvailable indicates that the condition transitioned to this state because the target was available
#TargetAvailable: "TargetAvailable"

// TargetNotAvailable indicates that the condition transitioned to this state because the target was not available
#TargetNotAvailable: "TargetNotAvailable"

// UnableToCheckTargetAvailability indicates that the condition transitioned to this state because operator was unable
// to check the target availability
#UnableToCheckTargetAvailability: "UnableToCheckTargetAvailability"

// SidecarInjectionSucceeded indicates that the condition transitioned to this state because sidecar was injected
// successfully into the targeted workload
#SidecarInjectionSucceeded: "SidecarInjectionSucceeded"

// SidecarInjectionFailed indicates that the condition transitioned to this state because operator was unable
// to inject sidecar into the targeted workload
#SidecarInjectionFailed: "SidecarInjectionFailed"

// CronJobCreationSucceeded indicates that the condition transitioned to this state because backup triggering CronJob was created successfully
#CronJobCreationSucceeded: "CronJobCreationSucceeded"

// CronJobCreationFailed indicates that the condition transitioned to this state because operator was unable to create backup triggering CronJob
#CronJobCreationFailed: "CronJobCreationFailed"

// RepositoryAvailable indicates that the condition transitioned to this state because the Repository was available
#RepositoryAvailable: "RepositoryAvailable"

// RepositoryNotAvailable indicates that the condition transitioned to this state because the Repository was not available
#RepositoryNotAvailable: "RepositoryNotAvailable"

// UnableToCheckRepositoryAvailability indicates that the condition transitioned to this state because operator was unable
// to check the Repository availability
#UnableToCheckRepositoryAvailability: "UnableToCheckRepositoryAvailability"

// BackendSecretAvailable indicates that the condition transitioned to this state because the backend Secret was available
#BackendSecretAvailable: "BackendSecretAvailable"

// BackendSecretNotAvailable indicates that the condition transitioned to this state because the backend Secret was not available
#BackendSecretNotAvailable: "BackendSecretNotAvailable"

// UnableToCheckBackendSecretAvailability indicates that the condition transitioned to this state because operator was unable
// to check the backend Secret availability
#UnableToCheckBackendSecretAvailability: "UnableToCheckBackendSecretAvailability"

// ResourceValidationPassed indicates that the condition transitioned to this state because the CRD meets validation criteria
#ResourceValidationPassed: "ResourceValidationPassed"

// ResourceValidationFailed indicates that the condition transitioned to this state because the CRD does not meet validation criteria
#ResourceValidationFailed: "ResourceValidationFailed"
