// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go stash.appscode.dev/apimachinery/apis/stash/v1beta1

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	core "k8s.io/api/core/v1"
	ofst "kmodules.xyz/offshoot-api/api/v1"
)

#ResourceKindFunction:     "Function"
#ResourcePluralFunction:   "functions"
#ResourceSingularFunction: "function"

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=functions,singular=function,scope=Cluster,shortName=fn,categories={stash,appscode}
// +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp"
#Function: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)
	spec?:     #FunctionSpec      @go(Spec)
}

#FunctionSpec: {
	// Docker image name.
	// More info: https://kubernetes.io/docs/concepts/containers/images
	// This field is optional to allow higher level config management to default or override
	// container images in workload controllers like Deployments and StatefulSets.
	// +optional
	image?: string @go(Image)

	// Entrypoint array. Not executed within a shell.
	// The docker image's ENTRYPOINT is used if this is not provided.
	// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
	// cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
	// can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
	// regardless of whether the variable exists or not.
	// Cannot be updated.
	// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
	// +optional
	command?: [...string] @go(Command,[]string)

	// Arguments to the entrypoint.
	// The docker image's CMD is used if this is not provided.
	// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
	// cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
	// can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
	// regardless of whether the variable exists or not.
	// Cannot be updated.
	// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
	// +optional
	args?: [...string] @go(Args,[]string)

	// Container's working directory.
	// If not specified, the container runtime's default will be used, which
	// might be configured in the container image.
	// Cannot be updated.
	// +optional
	workingDir?: string @go(WorkingDir)

	// List of ports to expose from the container. Exposing a port here gives
	// the system additional information about the network connections a
	// container uses, but is primarily informational. Not specifying a port here
	// DOES NOT prevent that port from being exposed. Any port which is
	// listening on the default "0.0.0.0" address inside a container will be
	// accessible from the network.
	// Cannot be updated.
	// +optional
	// +patchMergeKey=containerPort
	// +patchStrategy=merge
	ports?: [...core.#ContainerPort] @go(Ports,[]core.ContainerPort)

	// Pod volumes to mount into the container's filesystem.
	// Cannot be updated.
	// +optional
	// +patchMergeKey=mountPath
	// +patchStrategy=merge
	volumeMounts?: [...core.#VolumeMount] @go(VolumeMounts,[]core.VolumeMount)

	// volumeDevices is the list of block devices to be used by the container.
	// This is an alpha feature and may change in the future.
	// +patchMergeKey=devicePath
	// +patchStrategy=merge
	// +optional
	volumeDevices?: [...core.#VolumeDevice] @go(VolumeDevices,[]core.VolumeDevice)

	// RuntimeSettings allow to specify Resources, LivenessProbe, ReadinessProbe, Lifecycle, SecurityContext etc.
	// +optional
	runtimeSettings?: null | ofst.#ContainerRuntimeSettings @go(RuntimeSettings,*ofst.ContainerRuntimeSettings)

	// Name of PodSecurityPolicy(PSP) required by this function
	// +optional
	podSecurityPolicyName?: string @go(PodSecurityPolicyName)
}

#FunctionList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items?: [...#Function] @go(Items,[]Function)
}
