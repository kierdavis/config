// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go stash.appscode.dev/apimachinery/apis/stash/v1beta1

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
)

#ResourceKindBackupSession:     "BackupSession"
#ResourceSingularBackupSession: "backupsession"
#ResourcePluralBackupSession:   "backupsessions"

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=backupsessions,singular=backupsession,categories={stash,appscode,all}
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Invoker-Type",type="string",JSONPath=".spec.invoker.kind"
// +kubebuilder:printcolumn:name="Invoker-Name",type="string",JSONPath=".spec.invoker.name"
// +kubebuilder:printcolumn:name="Phase",type="string",JSONPath=".status.phase"
// +kubebuilder:printcolumn:name="Duration",type="string",JSONPath=".status.sessionDuration"
// +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp"
#BackupSession: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta   @go(ObjectMeta)
	spec?:     #BackupSessionSpec   @go(Spec)
	status?:   #BackupSessionStatus @go(Status)
}

#BackupSessionSpec: {
	// Invoker refers to the BackupConfiguration or BackupBatch being used to invoke this backup session
	// +optional
	invoker?: #BackupInvokerRef @go(Invoker)

	// RetryLeft specifies number of retry attempts left for the session.
	// If this set to non-zero, Stash will create a new BackupSession if the current one fails.
	// +optional
	retryLeft?: int32 @go(RetryLeft)
}

// +kubebuilder:validation:Enum=Pending;Skipped;Running;Succeeded;Failed;Unknown
#BackupSessionPhase: string // #enumBackupSessionPhase

#enumBackupSessionPhase:
	#BackupSessionPending |
	#BackupSessionSkipped |
	#BackupSessionRunning |
	#BackupSessionSucceeded |
	#BackupSessionFailed |
	#BackupSessionUnknown

#BackupSessionPending:   #BackupSessionPhase & "Pending"
#BackupSessionSkipped:   #BackupSessionPhase & "Skipped"
#BackupSessionRunning:   #BackupSessionPhase & "Running"
#BackupSessionSucceeded: #BackupSessionPhase & "Succeeded"
#BackupSessionFailed:    #BackupSessionPhase & "Failed"
#BackupSessionUnknown:   #BackupSessionPhase & "Unknown"

// +kubebuilder:validation:Enum=Succeeded;Failed
#HostBackupPhase: string // #enumHostBackupPhase

#enumHostBackupPhase:
	#HostBackupSucceeded |
	#HostBackupFailed

#HostBackupSucceeded: #HostBackupPhase & "Succeeded"
#HostBackupFailed:    #HostBackupPhase & "Failed"

// +kubebuilder:validation:Enum=Pending;Succeeded;Running;Failed
#TargetPhase: string // #enumTargetPhase

#enumTargetPhase:
	#TargetBackupPending |
	#TargetBackupSucceeded |
	#TargetBackupRunning |
	#TargetBackupFailed

#TargetBackupPending:   #TargetPhase & "Pending"
#TargetBackupSucceeded: #TargetPhase & "Succeeded"
#TargetBackupRunning:   #TargetPhase & "Running"
#TargetBackupFailed:    #TargetPhase & "Failed"

#BackupSessionStatus: {
	// Phase indicates the overall phase of the backup process for this BackupSession. Phase will be "Succeeded" only if
	// phase of all hosts are "Succeeded". If any of the host fail to complete backup, Phase will be "Failed".
	// +optional
	phase?: #BackupSessionPhase @go(Phase)

	// SessionDuration specify total time taken to complete current backup session (sum of backup duration of all targets)
	// +optional
	sessionDuration?: string @go(SessionDuration)

	// Targets specify the backup status of individual targets
	// +optional
	targets?: [...#BackupTargetStatus] @go(Targets,[]BackupTargetStatus)

	// Conditions shows condition of different operations/steps of the backup process
	// +optional
	conditions?: [...kmapi.#Condition] @go(Conditions,[]kmapi.Condition)

	// SessionDeadline specifies the deadline of backup. BackupSession will be
	// considered Failed if backup does not complete within this deadline
	// +optional
	sessionDeadline?: null | metav1.#Time @go(SessionDeadline,*metav1.Time)

	// Retried specifies whether this session was retried or not.
	// This field will exist only if the `retryConfig` has been set in the respective backup invoker.
	// +optional
	retried?: null | bool @go(Retried,*bool)

	// NextRetry specifies the time when Stash should retry the current failed backup.
	// This field will exist only if the `retryConfig` has been set in the respective backup invoker.
	// +optional
	nextRetry?: null | metav1.#Time @go(NextRetry,*metav1.Time)
}

#BackupTargetStatus: {
	// Ref refers to the backup target
	// +optional
	ref?: #TargetRef @go(Ref)

	// TotalHosts specifies total number of hosts for this target that will be backed up for a BackupSession
	// +optional
	totalHosts?: null | int32 @go(TotalHosts,*int32)

	// Phase indicates backup phase of this target
	// +optional
	phase?: #TargetPhase @go(Phase)

	// Stats shows statistics of individual hosts for this backup session
	// +optional
	stats?: [...#HostBackupStats] @go(Stats,[]HostBackupStats)

	// PreBackupActions specifies a list of actions that the backup process should execute before taking backup
	// +optional
	preBackupActions?: [...string] @go(PreBackupActions,[]string)

	// PostBackupActions specifies a list of actions that the backup process should execute after taking backup
	// +optional
	postBackupActions?: [...string] @go(PostBackupActions,[]string)

	// Conditions shows condition of different operations/steps of the backup process for this target
	// +optional
	conditions?: [...kmapi.#Condition] @go(Conditions,[]kmapi.Condition)
}

#HostBackupStats: {
	// Hostname indicate name of the host that has been backed up
	// +optional
	hostname?: string @go(Hostname)

	// Phase indicates backup phase of this host
	// +optional
	phase?: #HostBackupPhase @go(Phase)

	// Snapshots specifies the stats of individual snapshots that has been taken for this host in current backup session
	// +optional
	snapshots?: [...#SnapshotStats] @go(Snapshots,[]SnapshotStats)

	// Duration indicates total time taken to complete backup for this hosts
	// +optional
	duration?: string @go(Duration)

	// Error indicates string value of error in case of backup failure
	// +optional
	error?: string @go(Error)
}

#SnapshotStats: {
	// Name indicates the name of the backup snapshot created for this host
	name?: string @go(Name)

	// Path indicates the directory that has been backed up in this snapshot
	path?: string @go(Path)

	// TotalSize indicates the size of data to backup in target directory
	totalSize?: string @go(TotalSize)

	// Uploaded indicates size of data uploaded to backend for this snapshot
	uploaded?: string @go(Uploaded)

	// ProcessingTime indicates time taken to process the target data
	processingTime?: string @go(ProcessingTime)

	// FileStats shows statistics of files of this snapshot
	fileStats?: #FileStats @go(FileStats)
}

#FileStats: {
	// TotalFiles shows total number of files that has been backed up
	totalFiles?: null | int64 @go(TotalFiles,*int64)

	// NewFiles shows total number of new files that has been created since last backup
	newFiles?: null | int64 @go(NewFiles,*int64)

	// ModifiedFiles shows total number of files that has been modified since last backup
	modifiedFiles?: null | int64 @go(ModifiedFiles,*int64)

	// UnmodifiedFiles shows total number of files that has not been changed since last backup
	unmodifiedFiles?: null | int64 @go(UnmodifiedFiles,*int64)
}

#BackupSessionList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items?: [...#BackupSession] @go(Items,[]BackupSession)
}

#InitializeBackendRepository: "InitializeBackendRepository"

#ApplyRetentionPolicy:      "ApplyRetentionPolicy"
#VerifyRepositoryIntegrity: "VerifyRepositoryIntegrity"
#SendRepositoryMetrics:     "SendRepositoryMetrics"

// RetentionPolicyApplied indicates that whether the retention policies were applied or not
#RetentionPolicyApplied: "RetentionPolicyApplied"

// BackendRepositoryInitialized indicates that whether backend repository was initialized or not
#BackendRepositoryInitialized: "BackendRepositoryInitialized"

// RepositoryIntegrityVerified indicates whether the repository integrity check succeeded or not
#RepositoryIntegrityVerified: "RepositoryIntegrityVerified"

// RepositoryMetricsPushed indicates whether the Repository metrics for this backup session were pushed or not
#RepositoryMetricsPushed: "RepositoryMetricsPushed"

// BackupSkipped indicates that the current session was skipped
#BackupSkipped: "BackupSkipped"

// BackupHistoryCleaned indicates whether the backup history was cleaned or not according to backupHistoryLimit
#BackupHistoryCleaned: "BackupHistoryCleaned"

// BackupExecutorEnsured indicates whether the backup executor entity was created or not
#BackupExecutorEnsured: "BackupExecutorEnsured"

// PreBackupHookExecutionSucceeded indicates whether the preBackup hook was executed successfully or not
#PreBackupHookExecutionSucceeded: "PreBackupHookExecutionSucceeded"

// PostBackupHookExecutionSucceeded indicates whether the postBackup hook was executed successfully or not
#PostBackupHookExecutionSucceeded: "PostBackupHookExecutionSucceeded"

// DeadlineExceeded  indicates whether the session deadline was exceeded or not
#DeadlineExceeded: "DeadlineExceeded"

// SuccessfullyAppliedRetentionPolicy indicates that the condition transitioned to this state because the retention policies was applied successfully
#SuccessfullyAppliedRetentionPolicy: "SuccessfullyAppliedRetentionPolicy"

// FailedToApplyRetentionPolicy indicates that the condition transitioned to this state because the Stash was unable to apply the retention policies
#FailedToApplyRetentionPolicy: "FailedToApplyRetentionPolicy"

// BackendRepositoryFound indicates that the condition transitioned to this state because the restic repository was found in the backend
#BackendRepositoryFound: "BackendRepositoryFound"

// FailedToInitializeBackendRepository indicates that the condition transitioned to this state because the Stash was unable to initialize a repository in the backend
#FailedToInitializeBackendRepository: "FailedToInitializeBackendRepository"

// SuccessfullyVerifiedRepositoryIntegrity indicates that the condition transitioned to this state because the repository has passed the integrity check
#SuccessfullyVerifiedRepositoryIntegrity: "SuccessfullyVerifiedRepositoryIntegrity"

// FailedToVerifyRepositoryIntegrity indicates that the condition transitioned to this state because the repository has failed the integrity check
#FailedToVerifyRepositoryIntegrity: "FailedToVerifyRepositoryIntegrity"

// SuccessfullyPushedRepositoryMetrics indicates that the condition transitioned to this state because the repository metrics was successfully pushed to the pushgateway
#SuccessfullyPushedRepositoryMetrics: "SuccessfullyPushedRepositoryMetrics"

// FailedToPushRepositoryMetrics indicates that the condition transitioned to this state because the Stash was unable to push the repository metrics to the pushgateway
#FailedToPushRepositoryMetrics: "FailedToPushRepositoryMetrics"

// SkippedTakingNewBackup indicates that the backup was skipped because another backup was running or backup invoker is not ready state.
#SkippedTakingNewBackup:             "SkippedTakingNewBackup"
#SuccessfullyCleanedBackupHistory:   "SuccessfullyCleanedBackupHistory"
#FailedToCleanBackupHistory:         "FailedToCleanBackupHistory"
#SuccessfullyEnsuredBackupExecutor:  "SuccessfullyEnsuredBackupExecutor"
#FailedToEnsureBackupExecutor:       "FailedToEnsureBackupExecutor"
#SuccessfullyExecutedPreBackupHook:  "SuccessfullyExecutedPreBackupHook"
#FailedToExecutePreBackupHook:       "FailedToExecutePreBackupHook"
#SuccessfullyExecutedPostBackupHook: "SuccessfullyExecutedPostBackupHook"
#FailedToExecutePostBackupHook:      "FailedToExecutePostBackupHook"
#FailedToCompleteWithinDeadline:     "FailedToCompleteWithinDeadline"
