Fix for https://bugs.chromium.org/p/chromium/issues/detail?id=530482

The problem is that chromium tests whether IPv6 internet access is available
by trying to connect to a hardcoded address. If it appears to be unavailable,
it disables AAAA DNS queries for performance reasons. This means that AAAA
records for private networks will not be used, which is problematic for
IPv6-only private networks.

This patch solves this problem by checking to see if see if the computer
has at least one non-loopback, non-link-local IPv6 address - if it does,
AAAA lookups remain enabled and the connectivity test is skipped.


From 1de614ab93a8ac3d6adf96c62a1cc760aecff7a9 Mon Sep 17 00:00:00 2001
From: Paul Jensen <pauljensen@chromium.org>
Date: Tue, 07 Aug 2018 12:51:58 -0400
Subject: [PATCH] Fix IPv6 DNS on devices without IPv6 global routes

Bug: 530482
Change-Id: I94f1a1d2f4573c363dda95118ee224db46e0eb0e
---

diff --git a/net/dns/host_resolver_impl.cc b/net/dns/host_resolver_impl.cc
index 0d61e10..7c3febd 100644
--- a/net/dns/host_resolver_impl.cc
+++ b/net/dns/host_resolver_impl.cc
@@ -55,6 +55,7 @@
 #include "net/base/ip_address.h"
 #include "net/base/ip_endpoint.h"
 #include "net/base/net_errors.h"
+#include "net/base/network_interfaces.h"
 #include "net/base/trace_constants.h"
 #include "net/base/url_util.h"
 #include "net/dns/address_sorter.h"
@@ -129,6 +130,10 @@
     "Net.OSErrorsForGetAddrinfo";
 #endif
 
+bool IsIPv6LinkLocal(const IPAddress& address) {
+  return (address.bytes()[0] == 0xFE) && ((address.bytes()[1] & 0xC0) == 0x80);
+}
+
 // Gets a list of the likely error codes that getaddrinfo() can return
 // (non-exhaustive). These are the error codes that we will track via
 // a histogram.
@@ -380,6 +385,37 @@
 #endif  // defined(various platforms)
 }
 
+bool HaveSystemIPv6Addressses() {
+  NetworkInterfaceList interfaces;
+  if (!GetNetworkList(&interfaces, EXCLUDE_HOST_SCOPE_VIRTUAL_INTERFACES))
+    return false;
+  for (NetworkInterface i : interfaces) {
+    if (!i.address.IsIPv6())
+      continue;
+    if (i.address == IPAddress::IPv6Localhost() || IsIPv6LinkLocal(i.address))
+      continue;
+#if defined(OS_WIN)
+    if (i.friendly_name == "Teredo Tunneling Pseudo-Interface")
+      continue;
+#endif
+#if defined(OS_MACOSX)
+    // Ignore airdrop interfaces.
+    if (base::StartsWith(i.friendly_name, "awdl",
+                         base::CompareCase::SENSITIVE)) {
+      continue;
+    }
+#endif
+    // Remove VMware network interfaces as they're internal and should not be
+    // used to determine the network connection type.
+    if (base::ToLowerASCII(i.friendly_name).find("vmnet") !=
+        std::string::npos) {
+      continue;
+    }
+    return true;
+  }
+  return false;
+}
+
 // Creates NetLog parameters when the resolve failed.
 std::unique_ptr<base::Value> NetLogProcTaskFailedCallback(
     uint32_t attempt_number,
@@ -2061,6 +2097,7 @@
       num_dns_failures_(0),
       assume_ipv6_failure_on_wifi_(false),
       use_local_ipv6_(false),
+      system_has_ipv6_address_(false),
       last_ipv6_probe_result_(true),
       additional_resolver_flags_(0),
       fallback_to_proctask_(true),
@@ -2088,6 +2125,7 @@
     defined(OS_FUCHSIA)
   RunLoopbackProbeJob();
 #endif
+  RunFindSystemIPv6AddressesJob();
   NetworkChangeNotifier::AddIPAddressObserver(this);
   NetworkChangeNotifier::AddConnectionTypeObserver(this);
   NetworkChangeNotifier::AddDNSObserver(this);
@@ -2332,6 +2370,10 @@
   }
 }
 
+void HostResolverImpl::SetSystemHasIPv6Addresses(bool result) {
+  system_has_ipv6_address_ = result;
+}
+
 void HostResolverImpl::SetTaskRunnerForTesting(
     scoped_refptr<base::TaskRunner> task_runner) {
   proc_task_runner_ = std::move(task_runner);
@@ -2634,7 +2676,8 @@
       // that this query is UNSPECIFIED (see effective_address_family
       // check above) so the code requesting the resolution should be amenable
       // to receiving a IPv6 resolution.
-      !use_local_ipv6_ && ip_address == nullptr && !IsIPv6Reachable(net_log)) {
+      !use_local_ipv6_ && !system_has_ipv6_address_ && ip_address == nullptr &&
+      !IsIPv6Reachable(net_log)) {
     effective_address_family = ADDRESS_FAMILY_IPV4;
     effective_flags |= HOST_RESOLVER_DEFAULT_FAMILY_SET_DUE_TO_NO_IPV6;
   }
@@ -2682,9 +2725,7 @@
   DCHECK_EQ(ADDRESS_FAMILY_IPV6, endpoint.GetFamily());
   const IPAddress& address = endpoint.address();
 
-  bool is_link_local =
-      (address.bytes()[0] == 0xFE) && ((address.bytes()[1] & 0xC0) == 0x80);
-  if (is_link_local)
+  if (IsIPv6LinkLocal(address))
     return false;
 
   const uint8_t kTeredoPrefix[] = {0x20, 0x01, 0, 0};
@@ -2705,6 +2746,17 @@
                      weak_ptr_factory_.GetWeakPtr()));
 }
 
+void HostResolverImpl::RunFindSystemIPv6AddressesJob() {
+  // Run this asynchronously as it can block and should not block
+  // initialization.
+  base::PostTaskWithTraitsAndReplyWithResult(
+      FROM_HERE,
+      {base::MayBlock(), base::TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN},
+      base::BindOnce(&HaveSystemIPv6Addressses),
+      base::BindOnce(&HostResolverImpl::SetSystemHasIPv6Addresses,
+                     weak_ptr_factory_.GetWeakPtr()));
+}
+
 void HostResolverImpl::AbortAllInProgressJobs() {
   // In Abort, a Request callback could spawn new Jobs with matching keys, so
   // first collect and remove all running jobs from |jobs_|.
@@ -2781,6 +2833,7 @@
     defined(OS_FUCHSIA)
   RunLoopbackProbeJob();
 #endif
+  RunFindSystemIPv6AddressesJob();
   AbortAllInProgressJobs();
   // |this| may be deleted inside AbortAllInProgressJobs().
 }
diff --git a/net/dns/host_resolver_impl.h b/net/dns/host_resolver_impl.h
index eea6dd5..a3a66ed 100644
--- a/net/dns/host_resolver_impl.h
+++ b/net/dns/host_resolver_impl.h
@@ -188,6 +188,7 @@
  protected:
   // Callback from HaveOnlyLoopbackAddresses probe.
   void SetHaveOnlyLoopbackAddresses(bool result);
+  void SetSystemHasIPv6Addresses(bool result);
 
   // Sets the task runner used for HostResolverProc tasks.
   void SetTaskRunnerForTesting(scoped_refptr<base::TaskRunner> task_runner);
@@ -300,6 +301,8 @@
   // Asynchronously checks if only loopback IPs are available.
   virtual void RunLoopbackProbeJob();
 
+  void RunFindSystemIPv6AddressesJob();
+
   // Records the result in cache if cache is present.
   void CacheResult(const Key& key,
                    const HostCache::Entry& entry,
@@ -383,6 +386,9 @@
   // local IPv6 connectivity. Disables probing.
   bool use_local_ipv6_;
 
+  // True if system has a network adapter with a IPv6 address. Disables probing.
+  bool system_has_ipv6_address_;
+
   base::TimeTicks last_ipv6_probe_time_;
   bool last_ipv6_probe_result_;
 
